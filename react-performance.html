<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React性能优化完整指南 - Tawy2025</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="article.css">
    <link rel="stylesheet" href="css/force-stable.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="js/anti-flicker.js"></script>
    <script src="js/related-articles-fix.js"></script>
    <script src="js/ultimate-fix.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html">Tawy2025</a>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="index.html#home" class="nav-link">首页</a>
                </li>
                <li class="nav-item">
                    <a href="index.html#about" class="nav-link">关于我</a>
                </li>
                <li class="nav-item">
                    <a href="index.html#articles" class="nav-link">文章</a>
                </li>
                <li class="nav-item">
                    <a href="index.html#projects" class="nav-link">项目</a>
                </li>
                <li class="nav-item">
                    <a href="index.html#contact" class="nav-link">联系我</a>
                </li>
            </ul>
            <div class="nav-toggle" id="mobile-menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- 文章头部 -->
    <header class="article-header">
        <div class="container">
            <div class="breadcrumb">
                <a href="index.html">首页</a>
                <span>/</span>
                <a href="index.html#articles">文章</a>
                <span>/</span>
                <span>React性能优化完整指南</span>
            </div>
            <h1 class="article-title">React性能优化完整指南</h1>
            <div class="article-meta">
                <div class="meta-item">
                    <i class="fas fa-calendar"></i>
                    <span>2025年8月9日</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-tag"></i>
                    <span>React</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-clock"></i>
                    <span>阅读时间: 15分钟</span>
                </div>
                <div class="meta-item">
                    <i class="fas fa-eye"></i>
                    <span>浏览: 3,421次</span>
                </div>
            </div>
        </div>
    </header>

    <!-- 文章内容 -->
    <main class="article-main">
        <div class="container">
            <div class="article-layout">
                <!-- 文章内容 -->
                <article class="article-content">
                    <div class="article-summary">
                        <h2>文章摘要</h2>
                        <p>全面深入地探讨React应用的性能优化策略，从基础的渲染优化到高级的代码分割技术，帮助开发者构建高性能的React应用。包含实际案例和性能测试方法。</p>
                    </div>

                    <div class="article-toc">
                        <h3>目录</h3>
                        <ul>
                            <li><a href="#introduction">1. 性能优化概述</a></li>
                            <li><a href="#rendering">2. 渲染优化</a></li>
                            <li><a href="#memoization">3. 记忆化技术</a></li>
                            <li><a href="#code-splitting">4. 代码分割</a></li>
                            <li><a href="#state-management">5. 状态管理优化</a></li>
                            <li><a href="#measurement">6. 性能测量</a></li>
                        </ul>
                    </div>

                    <section id="introduction">
                        <h2>1. 性能优化概述</h2>
                        <p>React应用的性能优化是一个系统性工程，需要从多个维度进行考虑和实施。</p>
                        
                        <blockquote>
                            "过早的优化是万恶之源，但合理的优化是必要的。"
                        </blockquote>
                        
                        <h3>1.1 性能问题的常见表现</h3>
                        <ul>
                            <li>页面加载缓慢</li>
                            <li>用户交互响应延迟</li>
                            <li>滚动不流畅</li>
                            <li>内存泄漏</li>
                            <li>CPU使用率过高</li>
                        </ul>

                        <h3>1.2 优化策略分类</h3>
                        <pre><code class="language-javascript">// 性能优化的主要方向
const optimizationStrategies = {
    rendering: '渲染优化',
    bundling: '打包优化', 
    caching: '缓存策略',
    loading: '加载优化',
    memory: '内存管理'
};</code></pre>
                    </section>

                    <section id="rendering">
                        <h2>2. 渲染优化</h2>
                        <p>渲染优化是React性能优化的核心，主要通过减少不必要的重新渲染来提升性能。</p>
                        
                        <h3>2.1 React.memo的使用</h3>
                        <pre><code class="language-jsx">// 使用React.memo防止不必要的重新渲染
import React, { memo } from 'react';

// 普通组件 - 每次父组件更新都会重新渲染
const ExpensiveComponent = ({ data, onUpdate }) => {
    console.log('ExpensiveComponent 渲染'); // 会频繁打印
    
    return (
        &lt;div&gt;
            {data.map(item => (
                &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;
            ))}
            &lt;button onClick={onUpdate}&gt;更新&lt;/button&gt;
        &lt;/div&gt;
    );
};

// 优化后的组件 - 只有props变化时才重新渲染
const OptimizedComponent = memo(({ data, onUpdate }) => {
    console.log('OptimizedComponent 渲染'); // 只在必要时打印
    
    return (
        &lt;div&gt;
            {data.map(item => (
                &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;
            ))}
            &lt;button onClick={onUpdate}&gt;更新&lt;/button&gt;
        &lt;/div&gt;
    );
});

// 自定义比较函数
const DeepOptimizedComponent = memo(({ data, config }) => {
    return (
        &lt;div&gt;
            {/* 组件内容 */}
        &lt;/div&gt;
    );
}, (prevProps, nextProps) => {
    // 自定义比较逻辑
    return (
        prevProps.data.length === nextProps.data.length &&
        prevProps.config.theme === nextProps.config.theme
    );
});</code></pre>

                        <h3>2.2 useMemo和useCallback</h3>
                        <pre><code class="language-jsx">import React, { useMemo, useCallback, useState } from 'react';

const DataVisualization = ({ rawData, filters }) => {
    const [sortOrder, setSortOrder] = useState('asc');
    
    // 使用useMemo缓存计算结果
    const processedData = useMemo(() => {
        console.log('处理数据...'); // 只在依赖变化时执行
        
        return rawData
            .filter(item => filters.includes(item.category))
            .sort((a, b) => {
                return sortOrder === 'asc' 
                    ? a.value - b.value 
                    : b.value - a.value;
            })
            .map(item => ({
                ...item,
                formattedValue: item.value.toLocaleString()
            }));
    }, [rawData, filters, sortOrder]);
    
    // 使用useCallback缓存函数
    const handleSort = useCallback((newOrder) => {
        setSortOrder(newOrder);
    }, []);
    
    const handleItemClick = useCallback((itemId) => {
        console.log('点击项目:', itemId);
        // 处理点击逻辑
    }, []);
    
    return (
        &lt;div&gt;
            &lt;SortControls onSort={handleSort} currentOrder={sortOrder} /&gt;
            &lt;DataList 
                data={processedData} 
                onItemClick={handleItemClick}
            /&gt;
        &lt;/div&gt;
    );
};

// 子组件也需要优化
const SortControls = memo(({ onSort, currentOrder }) => {
    return (
        &lt;div&gt;
            &lt;button 
                onClick={() => onSort('asc')}
                className={currentOrder === 'asc' ? 'active' : ''}
            &gt;
                升序
            &lt;/button&gt;
            &lt;button 
                onClick={() => onSort('desc')}
                className={currentOrder === 'desc' ? 'active' : ''}
            &gt;
                降序
            &lt;/button&gt;
        &lt;/div&gt;
    );
});</code></pre>
                    </section>

                    <section id="memoization">
                        <h2>3. 记忆化技术</h2>
                        <p>记忆化是一种重要的优化技术，可以避免重复计算和渲染。</p>
                        
                        <h3>3.1 复杂计算的记忆化</h3>
                        <pre><code class="language-jsx">import React, { useMemo } from 'react';

// 复杂的数据处理函数
const processLargeDataset = (data, config) => {
    console.log('执行复杂计算...');
    
    // 模拟复杂计算
    return data
        .filter(item => item.active)
        .map(item => {
            // 复杂的数据转换
            const processed = {
                ...item,
                score: calculateScore(item, config),
                trend: calculateTrend(item.history),
                recommendations: generateRecommendations(item)
            };
            
            return processed;
        })
        .sort((a, b) => b.score - a.score);
};

const AnalyticsDashboard = ({ data, config, timeRange }) => {
    // 记忆化复杂计算
    const processedAnalytics = useMemo(() => {
        return processLargeDataset(data, config);
    }, [data, config]); // 注意：timeRange没有包含在依赖中
    
    // 基于时间范围的过滤（轻量级计算，不需要记忆化）
    const filteredData = processedAnalytics.filter(item => {
        return item.timestamp >= timeRange.start && 
               item.timestamp <= timeRange.end;
    });
    
    return (
        &lt;div&gt;
            &lt;h2&gt;分析报告&lt;/h2&gt;
            {filteredData.map(item => (
                &lt;AnalyticsCard key={item.id} data={item} /&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>

                        <h3>3.2 自定义记忆化Hook</h3>
                        <pre><code class="language-jsx">import { useRef, useCallback } from 'react';

// 自定义记忆化Hook，支持多参数
function useMemorize(fn, deps) {
    const cache = useRef(new Map());
    
    return useCallback((...args) => {
        const key = JSON.stringify([...args, ...deps]);
        
        if (cache.current.has(key)) {
            console.log('缓存命中');
            return cache.current.get(key);
        }
        
        console.log('计算新结果');
        const result = fn(...args);
        cache.current.set(key, result);
        
        // 限制缓存大小
        if (cache.current.size > 100) {
            const firstKey = cache.current.keys().next().value;
            cache.current.delete(firstKey);
        }
        
        return result;
    }, deps);
}

// 使用示例
const SearchResults = ({ query, filters, sortBy }) => {
    const searchFunction = useMemorize((q, f, s) => {
        // 复杂的搜索逻辑
        return performSearch(q, f, s);
    }, []);
    
    const results = searchFunction(query, filters, sortBy);
    
    return (
        &lt;div&gt;
            {results.map(item => (
                &lt;SearchResultItem key={item.id} item={item} /&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                    </section>

                    <section id="code-splitting">
                        <h2>4. 代码分割</h2>
                        <p>代码分割可以显著减少初始加载时间，提升用户体验。</p>
                        
                        <h3>4.1 路由级别的代码分割</h3>
                        <pre><code class="language-jsx">import React, { Suspense, lazy } from 'react';
import { Routes, Route } from 'react-router-dom';

// 懒加载组件
const Home = lazy(() => import('./pages/Home'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));
const Settings = lazy(() => import('./pages/Settings'));

// 加载失败时的错误边界
class LazyLoadErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }
    
    static getDerivedStateFromError(error) {
        return { hasError: true };
    }
    
    componentDidCatch(error, errorInfo) {
        console.error('懒加载失败:', error, errorInfo);
    }
    
    render() {
        if (this.state.hasError) {
            return (
                &lt;div className="error-fallback"&gt;
                    &lt;h2&gt;页面加载失败&lt;/h2&gt;
                    &lt;button onClick={() => window.location.reload()}&gt;
                        重新加载
                    &lt;/button&gt;
                &lt;/div&gt;
            );
        }
        
        return this.props.children;
    }
}

// 加载中组件
const LoadingSpinner = () => (
    &lt;div className="loading-container"&gt;
        &lt;div className="spinner"&gt;&lt;/div&gt;
        &lt;p&gt;加载中...&lt;/p&gt;
    &lt;/div&gt;
);

const App = () => {
    return (
        &lt;LazyLoadErrorBoundary&gt;
            &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
                &lt;Routes&gt;
                    &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                    &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
                    &lt;Route path="/profile" element={&lt;Profile /&gt;} /&gt;
                    &lt;Route path="/settings" element={&lt;Settings /&gt;} /&gt;
                &lt;/Routes&gt;
            &lt;/Suspense&gt;
        &lt;/LazyLoadErrorBoundary&gt;
    );
};</code></pre>

                        <h3>4.2 组件级别的懒加载</h3>
                        <pre><code class="language-jsx">import React, { useState, Suspense, lazy } from 'react';

// 懒加载重型组件
const HeavyChart = lazy(() => import('./components/HeavyChart'));
const DataTable = lazy(() => import('./components/DataTable'));
const ExportModal = lazy(() => import('./components/ExportModal'));

const Dashboard = () => {
    const [activeTab, setActiveTab] = useState('overview');
    const [showExportModal, setShowExportModal] = useState(false);
    
    return (
        &lt;div className="dashboard"&gt;
            &lt;div className="dashboard-header"&gt;
                &lt;h1&gt;数据仪表板&lt;/h1&gt;
                &lt;button onClick={() => setShowExportModal(true)}&gt;
                    导出数据
                &lt;/button&gt;
            &lt;/div&gt;
            
            &lt;div className="dashboard-tabs"&gt;
                &lt;button 
                    onClick={() => setActiveTab('overview')}
                    className={activeTab === 'overview' ? 'active' : ''}
                &gt;
                    概览
                &lt;/button&gt;
                &lt;button 
                    onClick={() => setActiveTab('charts')}
                    className={activeTab === 'charts' ? 'active' : ''}
                &gt;
                    图表
                &lt;/button&gt;
                &lt;button 
                    onClick={() => setActiveTab('data')}
                    className={activeTab === 'data' ? 'active' : ''}
                &gt;
                    数据表
                &lt;/button&gt;
            &lt;/div&gt;
            
            &lt;div className="dashboard-content"&gt;
                {activeTab === 'overview' && (
                    &lt;div&gt;概览内容...&lt;/div&gt;
                )}
                
                {activeTab === 'charts' && (
                    &lt;Suspense fallback={&lt;div&gt;加载图表中...&lt;/div&gt;}&gt;
                        &lt;HeavyChart /&gt;
                    &lt;/Suspense&gt;
                )}
                
                {activeTab === 'data' && (
                    &lt;Suspense fallback={&lt;div&gt;加载数据表中...&lt;/div&gt;}&gt;
                        &lt;DataTable /&gt;
                    &lt;/Suspense&gt;
                )}
            &lt;/div&gt;
            
            {showExportModal && (
                &lt;Suspense fallback={&lt;div&gt;加载导出功能...&lt;/div&gt;}&gt;
                    &lt;ExportModal onClose={() => setShowExportModal(false)} /&gt;
                &lt;/Suspense&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                    </section>

                    <section id="state-management">
                        <h2>5. 状态管理优化</h2>
                        <p>合理的状态管理可以避免不必要的渲染和计算。</p>
                        
                        <h3>5.1 状态分离和局部化</h3>
                        <pre><code class="language-jsx">// ❌ 错误做法：所有状态都放在顶层
const BadApp = () => {
    const [userProfile, setUserProfile] = useState({});
    const [dashboardData, setDashboardData] = useState([]);
    const [modalVisible, setModalVisible] = useState(false);
    const [formData, setFormData] = useState({});
    const [searchQuery, setSearchQuery] = useState('');
    
    // 任何状态变化都会导致整个App重新渲染
    return (
        &lt;div&gt;
            &lt;Header user={userProfile} /&gt;
            &lt;Dashboard data={dashboardData} /&gt;
            &lt;SearchBox query={searchQuery} onChange={setSearchQuery} /&gt;
            {modalVisible && &lt;Modal data={formData} /&gt;}
        &lt;/div&gt;
    );
};

// ✅ 正确做法：状态局部化
const GoodApp = () => {
    const [userProfile, setUserProfile] = useState({});
    
    return (
        &lt;div&gt;
            &lt;Header user={userProfile} /&gt;
            &lt;DashboardContainer /&gt; {/* 内部管理自己的状态 */}
            &lt;SearchContainer /&gt;   {/* 内部管理自己的状态 */}
        &lt;/div&gt;
    );
};

// 独立的Dashboard容器
const DashboardContainer = () => {
    const [dashboardData, setDashboardData] = useState([]);
    const [loading, setLoading] = useState(false);
    
    return &lt;Dashboard data={dashboardData} loading={loading} /&gt;;
};

// 独立的搜索容器
const SearchContainer = () => {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState([]);
    
    return (
        &lt;div&gt;
            &lt;SearchBox query={query} onChange={setQuery} /&gt;
            &lt;SearchResults results={results} /&gt;
        &lt;/div&gt;
    );
};</code></pre>

                        <h3>5.2 使用useReducer管理复杂状态</h3>
                        <pre><code class="language-jsx">import React, { useReducer, useMemo } from 'react';

// 复杂状态的reducer
const todoReducer = (state, action) => {
    switch (action.type) {
        case 'ADD_TODO':
            return {
                ...state,
                todos: [...state.todos, {
                    id: Date.now(),
                    text: action.payload,
                    completed: false,
                    createdAt: new Date()
                }]
            };
            
        case 'TOGGLE_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload
                        ? { ...todo, completed: !todo.completed }
                        : todo
                )
            };
            
        case 'DELETE_TODO':
            return {
                ...state,
                todos: state.todos.filter(todo => todo.id !== action.payload)
            };
            
        case 'SET_FILTER':
            return {
                ...state,
                filter: action.payload
            };
            
        default:
            return state;
    }
};

const TodoApp = () => {
    const [state, dispatch] = useReducer(todoReducer, {
        todos: [],
        filter: 'all' // 'all', 'active', 'completed'
    });
    
    // 使用useMemo缓存过滤后的todos
    const filteredTodos = useMemo(() => {
        switch (state.filter) {
            case 'active':
                return state.todos.filter(todo => !todo.completed);
            case 'completed':
                return state.todos.filter(todo => todo.completed);
            default:
                return state.todos;
        }
    }, [state.todos, state.filter]);
    
    // 统计信息也使用useMemo缓存
    const stats = useMemo(() => ({
        total: state.todos.length,
        active: state.todos.filter(todo => !todo.completed).length,
        completed: state.todos.filter(todo => todo.completed).length
    }), [state.todos]);
    
    return (
        &lt;div&gt;
            &lt;TodoInput onAdd={(text) => dispatch({ type: 'ADD_TODO', payload: text })} /&gt;
            &lt;TodoFilters 
                current={state.filter}
                onChange={(filter) => dispatch({ type: 'SET_FILTER', payload: filter })}
            /&gt;
            &lt;TodoList 
                todos={filteredTodos}
                onToggle={(id) => dispatch({ type: 'TOGGLE_TODO', payload: id })}
                onDelete={(id) => dispatch({ type: 'DELETE_TODO', payload: id })}
            /&gt;
            &lt;TodoStats stats={stats} /&gt;
        &lt;/div&gt;
    );
};</code></pre>
                    </section>

                    <section id="measurement">
                        <h2>6. 性能测量</h2>
                        <p>性能优化需要基于数据，而不是猜测。以下是一些实用的性能测量方法。</p>
                        
                        <h3>6.1 React DevTools Profiler</h3>
                        <pre><code class="language-jsx">import React, { Profiler } from 'react';

// 性能测量回调
const onRenderCallback = (id, phase, actualDuration, baseDuration, startTime, commitTime) => {
    console.log('组件渲染性能:', {
        id,           // 组件标识
        phase,        // 'mount' 或 'update'
        actualDuration, // 实际渲染时间
        baseDuration,   // 估计渲染时间
        startTime,      // 开始时间
        commitTime      // 提交时间
    });
    
    // 可以发送到分析服务
    if (actualDuration > 16) { // 超过16ms可能影响60fps
        analytics.track('slow_render', {
            component: id,
            duration: actualDuration,
            phase
        });
    }
};

const App = () => {
    return (
        &lt;Profiler id="App" onRender={onRenderCallback}&gt;
            &lt;Header /&gt;
            &lt;Profiler id="Dashboard" onRender={onRenderCallback}&gt;
                &lt;Dashboard /&gt;
            &lt;/Profiler&gt;
            &lt;Footer /&gt;
        &lt;/Profiler&gt;
    );
};</code></pre>

                        <h3>6.2 自定义性能监控Hook</h3>
                        <pre><code class="language-jsx">import { useEffect, useRef } from 'react';

// 自定义性能监控Hook
const usePerformanceMonitor = (componentName) => {
    const renderCount = useRef(0);
    const startTime = useRef(0);
    
    useEffect(() => {
        renderCount.current += 1;
        const endTime = performance.now();
        
        if (startTime.current > 0) {
            const duration = endTime - startTime.current;
            console.log(`${componentName} 渲染 #${renderCount.current}, 耗时: ${duration.toFixed(2)}ms`);
        }
        
        startTime.current = endTime;
    });
    
    // 返回性能统计
    return {
        renderCount: renderCount.current,
        measureRender: (callback) => {
            const start = performance.now();
            const result = callback();
            const end = performance.now();
            console.log(`${componentName} 操作耗时: ${(end - start).toFixed(2)}ms`);
            return result;
        }
    };
};

// 使用示例
const ExpensiveComponent = ({ data }) => {
    const { renderCount, measureRender } = usePerformanceMonitor('ExpensiveComponent');
    
    const processedData = measureRender(() => {
        return data.map(item => ({
            ...item,
            processed: expensiveCalculation(item)
        }));
    });
    
    return (
        &lt;div&gt;
            &lt;p&gt;渲染次数: {renderCount}&lt;/p&gt;
            {processedData.map(item => (
                &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>

                        <h3>6.3 Web Vitals监控</h3>
                        <pre><code class="language-javascript">// 安装: npm install web-vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

// 收集性能指标
const sendToAnalytics = (metric) => {
    console.log(metric);
    
    // 发送到分析服务
    fetch('/api/analytics', {
        method: 'POST',
        body: JSON.stringify(metric),
        headers: { 'Content-Type': 'application/json' }
    });
};

// 监控所有关键指标
getCLS(sendToAnalytics);  // 累积布局偏移
getFID(sendToAnalytics);  // 首次输入延迟
getFCP(sendToAnalytics);  // 首次内容绘制
getLCP(sendToAnalytics);  // 最大内容绘制
getTTFB(sendToAnalytics); // 首字节时间

// React组件中使用
const App = () => {
    useEffect(() => {
        // 页面加载完成后测量
        getLCP((metric) => {
            if (metric.value > 2500) { // LCP超过2.5秒
                console.warn('LCP过慢:', metric.value);
            }
        });
    }, []);
    
    return &lt;div&gt;{/* 应用内容 */}&lt;/div&gt;;
};</code></pre>
                    </section>

                    <!-- 文章标签 -->
                    <div class="article-tags">
                        <h3>标签</h3>
                        <div class="tags-list">
                            <span class="tag">React</span>
                            <span class="tag">性能优化</span>
                            <span class="tag">记忆化</span>
                            <span class="tag">代码分割</span>
                            <span class="tag">状态管理</span>
                        </div>
                    </div>

                    <!-- 分享按钮 -->
                    <div class="article-share">
                        <h3>分享文章</h3>
                        <div class="share-buttons">
                            <button class="share-btn" data-platform="twitter">
                                <i class="fab fa-twitter"></i>
                                Twitter
                            </button>
                            <button class="share-btn" data-platform="linkedin">
                                <i class="fab fa-linkedin"></i>
                                LinkedIn
                            </button>
                            <button class="share-btn" data-platform="weibo">
                                <i class="fab fa-weibo"></i>
                                微博
                            </button>
                            <button class="share-btn" data-platform="copy">
                                <i class="fas fa-link"></i>
                                复制链接
                            </button>
                        </div>
                    </div>
                </article>

                <!-- 侧边栏 -->
                <aside class="article-sidebar">
                    <!-- 作者信息 -->
                    <div class="author-card">
                        <div id="author-avatar-container">
                            <!-- 作者信息将在这里渲染 -->
                        </div>
                    </div>

                    <!-- 相关文章 -->
                    <div class="related-articles" style="opacity: 1 !important; visibility: visible !important; transform: none !important; transition: none !important;">
                        <h3 style="opacity: 1 !important; visibility: visible !important;">相关文章</h3>
                        <div class="related-list" style="opacity: 1 !important; visibility: visible !important;">
                            <article class="related-item" style="opacity: 1 !important; visibility: visible !important; transform: none !important;">
                                <h4 style="opacity: 1 !important; visibility: visible !important;"><a href="article.html" style="opacity: 1 !important; visibility: visible !important;">现代前端开发最佳实践</a></h4>
                                <span class="related-date" style="opacity: 1 !important; visibility: visible !important;">2025-08-9</span>
                            </article>
                            <article class="related-item" style="opacity: 1 !important; visibility: visible !important; transform: none !important;">
                                <h4 style="opacity: 1 !important; visibility: visible !important;"><a href="responsive-design.html" style="opacity: 1 !important; visibility: visible !important;">响应式设计完整指南</a></h4>
                                <span class="related-date" style="opacity: 1 !important; visibility: visible !important;">2025-08-09</span>
                            </article>
                        </div>
                    </div>

                    <!-- 目录导航 -->
                    <div class="toc-sidebar">
                        <h3>文章目录</h3>
                        <ul class="toc-list">
                            <li><a href="#introduction" class="toc-link">性能优化概述</a></li>
                            <li><a href="#rendering" class="toc-link">渲染优化</a></li>
                            <li><a href="#memoization" class="toc-link">记忆化技术</a></li>
                            <li><a href="#code-splitting" class="toc-link">代码分割</a></li>
                            <li><a href="#state-management" class="toc-link">状态管理优化</a></li>
                            <li><a href="#measurement" class="toc-link">性能测量</a></li>
                        </ul>
                    </div>
                </aside>
            </div>
        </div>
    </main>

    <!-- 评论区域 -->
    <section class="comments-section">
        <div class="container">
            <h2>评论 (4)</h2>
            
            <!-- 评论表单 -->
            <div class="comment-form">
                <h3>发表评论</h3>
                <form>
                    <div class="form-row">
                        <input type="text" placeholder="您的姓名" required>
                        <input type="email" placeholder="您的邮箱" required>
                    </div>
                    <textarea placeholder="您的评论..." rows="4" required></textarea>
                    <button type="submit">发表评论</button>
                </form>
            </div>

            <!-- 评论列表 -->
            <div class="comments-list">
                <div class="comment">
                    <div class="comment-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">React开发者</span>
                            <span class="comment-date">2025-08-09 10:30</span>
                        </div>
                        <p>太实用了！useMemo和useCallback的使用场景讲得很清楚，特别是自定义记忆化Hook的实现很赞👍</p>
                        <div class="comment-actions">
                            <button class="reply-btn">回复</button>
                            <button class="like-btn"><i class="fas fa-thumbs-up"></i> 12</button>
                        </div>
                    </div>
                </div>

                <div class="comment">
                    <div class="comment-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">性能专家</span>
                            <span class="comment-date">2025-08-09 14:15</span>
                        </div>
                        <p>代码分割的部分很详细，错误边界的处理也很到位。建议补充一下bundle analyzer的使用方法。</p>
                        <div class="comment-actions">
                            <button class="reply-btn">回复</button>
                            <button class="like-btn"><i class="fas fa-thumbs-up"></i> 8</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Tawy的个人博客. 保留所有权利.</p>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="js/author-data.js"></script>
    <script src="script.js"></script>
    <script src="article.js"></script>
</body>
</html>
